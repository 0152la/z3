#include <stddef.h>
#include <string.h>
#include <assert.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <caml/mlvalues.h>
#include <caml/memory.h>
#include <caml/alloc.h>
#include <caml/fail.h>
#include <caml/callback.h>

#ifdef Custom_tag
#include <caml/custom.h>
#include <caml/bigarray.h>
#endif

#ifdef __cplusplus
}
#endif

#include <z3.h>
#include <z3native_stubs.h>

#define CAMLlocal6(X1,X2,X3,X4,X5,X6)                               \
  CAMLlocal5(X1,X2,X3,X4,X5);                                       \
  CAMLlocal1(X6)                                                      
#define CAMLlocal7(X1,X2,X3,X4,X5,X6,X7)                            \
  CAMLlocal5(X1,X2,X3,X4,X5);                                       \
  CAMLlocal2(X6,X7)                                                   
#define CAMLlocal8(X1,X2,X3,X4,X5,X6,X7,X8)                         \
  CAMLlocal5(X1,X2,X3,X4,X5);                                       \
  CAMLlocal3(X6,X7,X8)                                                

#define CAMLparam7(X1,X2,X3,X4,X5,X6,X7)                            \
  CAMLparam5(X1,X2,X3,X4,X5);                                       \
  CAMLxparam2(X6,X7)                                                  
#define CAMLparam8(X1,X2,X3,X4,X5,X6,X7,X8)                         \
  CAMLparam5(X1,X2,X3,X4,X5);                                       \
  CAMLxparam3(X6,X7,X8)                                               
#define CAMLparam9(X1,X2,X3,X4,X5,X6,X7,X8,X9)                      \
  CAMLparam5(X1,X2,X3,X4,X5);                                       \
  CAMLxparam4(X6,X7,X8,X9)
#define CAMLparam12(X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12)     \
  CAMLparam5(X1,X2,X3,X4,X5);                                   \
  CAMLxparam5(X6,X7,X8,X9,X10);                                 \
  CAMLxparam2(X11,X12)                                                
#define CAMLparam13(X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13) \
  CAMLparam5(X1,X2,X3,X4,X5);                                   \
  CAMLxparam5(X6,X7,X8,X9,X10);                                 \
  CAMLxparam3(X11,X12,X13)                                            


static struct custom_operations default_custom_ops = {
  (char*) "default handling",
  custom_finalize_default,
  custom_compare_default,
  custom_hash_default,
  custom_serialize_default,
  custom_deserialize_default,
  custom_compare_ext_default,
};


#define MK_CTX_OF(X)                                                    \
  CAMLprim DLL_PUBLIC value n_context_of_ ## X(value v) {               \
    CAMLparam1(v);                                                      \
    CAMLlocal1(result);                                                 \
    Z3_ ## X ## _plus * p = (Z3_ ## X ## _plus *) Data_custom_val(v);   \
    result = caml_alloc_custom(&Z3_context_plus_custom_ops, sizeof(Z3_context_plus), 0, 1); \
    *(Z3_context_plus*)Data_custom_val(result) = *p->cp;                \
    CAMLreturn(result);                                                 \
  }


/* Context objects */

typedef struct {
  Z3_context ctx;
  unsigned long obj_count:sizeof(unsigned long)-1;
  unsigned ok_to_delete:1;
} Z3_context_plus;

Z3_context_plus Z3_context_plus_mk(Z3_context c) {
  Z3_context_plus r;
  r.ctx = c;
  r.obj_count = 0;
  r.ok_to_delete = 0;
  /* printf("ctx++ %p\n", c); */
  return r;
}

Z3_context Z3_context_plus_raw(Z3_context_plus * cp) {
  return cp->ctx;
}

void try_to_delete_context(Z3_context_plus * cp) {
  if (!cp->ok_to_delete || cp->obj_count != 0)
    /* printf("Trying to delete context %p.\n", cp->ctx) */ ;
  else {
    /* printf("Actually deleting context %p.\n", cp->ctx); */
    Z3_del_context(cp->ctx);
    cp->ctx = 0;
    cp->obj_count = 0;
    cp->ok_to_delete = 0;
  }
}

void Z3_context_finalize(value v) {
  Z3_context_plus * cp = (Z3_context_plus*)Data_custom_val(v);
  /* printf("ctx--; cnt=%lu\n", cp->obj_count); */
  cp->ok_to_delete = 1;
  try_to_delete_context(cp);  
}

static struct custom_operations Z3_context_plus_custom_ops = {
  (char*) "Z3_context ops",
  Z3_context_finalize,
  custom_compare_default,
  custom_hash_default,
  custom_serialize_default,
  custom_deserialize_default,
  custom_compare_ext_default,
};


/* AST objects */

typedef struct {
  Z3_context_plus * cp;
  Z3_ast a;
} Z3_ast_plus;

Z3_ast_plus Z3_ast_plus_mk(Z3_context_plus * cp, Z3_ast a) {
  Z3_ast_plus r;
  r.cp = cp;
  r.a  = a;
  /* printf("++\n"); */
  cp->obj_count++;
  Z3_inc_ref(cp->ctx, a);
  return r;
}

Z3_ast Z3_ast_plus_raw(Z3_ast_plus * ap) {
  return ap->a;
}

void Z3_ast_finalize(value v) {
  /* printf("--\n"); */ 
  Z3_ast_plus * ap = (Z3_ast_plus*)(Data_custom_val(v));
  Z3_dec_ref(ap->cp->ctx, ap->a);
  ap->cp->obj_count--;
  try_to_delete_context(ap->cp);
}

int Z3_ast_compare(value v1, value v2) {
  Z3_ast_plus * a1 = (Z3_ast_plus*)Data_custom_val(v1);
  Z3_ast_plus * a2 = (Z3_ast_plus*)Data_custom_val(v2);
  assert(a1->cp->ctx == a2->cp->ctx);
  unsigned id1 = Z3_get_ast_id(a1->cp->ctx, a1->a);
  unsigned id2 = Z3_get_ast_id(a2->cp->ctx, a2->a);
  if (id1 == id2)
    return 0;
  else if (id1 < id2)
    return -1;
  else
    return +1;
}

int Z3_ast_compare_ext(value v1, value v2) {
  Z3_ast_plus * a1 = (Z3_ast_plus*)Data_custom_val(v1);
  unsigned id1 = Z3_get_ast_id(a1->cp->ctx, a1->a);
  int id2 = Val_int(v2);
  if (id1 == id2)
    return 0;
  else if (id1 < id2)
    return -1;
  else
    return +1;
}

intnat Z3_ast_hash(value v) {
  Z3_ast_plus * ap = (Z3_ast_plus*)Data_custom_val(v);
  return Z3_get_ast_hash(ap->cp->ctx, ap->a);
}

static struct custom_operations Z3_ast_plus_custom_ops = {
  (char*) "Z3_ast ops",
  Z3_ast_finalize,
  Z3_ast_compare,
  Z3_ast_hash,
  custom_serialize_default,
  custom_deserialize_default,
  Z3_ast_compare_ext
};

MK_CTX_OF(ast)




#define MK_PLUS_OBJ_NO_REF(X)                                           \
  typedef struct {                                                      \
    Z3_context_plus *  cp;                                              \
    Z3_ ## X p;                                                         \
  } Z3_ ## X ## _plus;                                                  \
                                                                        \
  Z3_ ## X ## _plus Z3_ ## X ## _plus_mk(Z3_context_plus * cp, Z3_ ## X p) { \
    Z3_ ## X ## _plus  r;                                               \
      r.cp = cp;                                                        \
      r.p = p;                                                          \
      r.cp->obj_count++;                                                \
      return r;                                                         \
  }                                                                     \
                                                                        \
  Z3_ ## X Z3_ ## X ## _plus_raw(Z3_ ## X ## _plus * pp) {              \
    return pp->p;                                                       \
  }                                                                     \
                                                                        \
  void Z3_ ## X ## _finalize(value v) {                                 \
    Z3_ ## X ## _plus * pp = (Z3_ ## X ## _plus*)Data_custom_val(v);    \
    pp->cp->obj_count--;                                                \
    try_to_delete_context(pp->cp);                                      \
  }                                                                     \
                                                                        \
  static struct custom_operations Z3_ ## X ## _plus_custom_ops = {      \
    (char*) "Z3_" #X " ops",                                            \
    Z3_ ## X ## _finalize,                                              \
    custom_compare_default,                                             \
    custom_hash_default,                                                \
    custom_serialize_default,                                           \
    custom_deserialize_default,                                         \
    custom_compare_ext_default,                                         \
  };                                                                    \
                                                                        \
  MK_CTX_OF(X)

#define MK_PLUS_OBJ(X)                                                  \
  typedef struct {                                                      \
    Z3_context_plus *  cp;                                              \
    Z3_ ## X p;                                                         \
  } Z3_ ## X ## _plus;                                                  \
                                                                        \
  Z3_ ## X ## _plus Z3_ ## X ## _plus_mk(Z3_context_plus * cp, Z3_ ## X p) { \
    Z3_ ## X ## _plus  r;                                               \
      r.cp = cp;                                                        \
      r.p = p;                                                          \
      r.cp->obj_count++;                                                \
      Z3_ ## X ## _inc_ref(cp->ctx, p);                                 \
      return r;                                                         \
  }                                                                     \
                                                                        \
  Z3_ ## X Z3_ ## X ## _plus_raw(Z3_ ## X ## _plus * pp) {              \
    return pp->p;                                                       \
  }                                                                     \
                                                                        \
  void Z3_ ## X ## _finalize(value v) {                                 \
    Z3_ ## X ## _plus * pp = (Z3_ ## X ## _plus*)Data_custom_val(v);    \
    Z3_ ## X ## _dec_ref(pp->cp->ctx, pp->p);                           \
    pp->cp->obj_count--;                                                \
    try_to_delete_context(pp->cp);                                      \
  }                                                                     \
                                                                        \
  static struct custom_operations Z3_ ## X ## _plus_custom_ops = {      \
    (char*) "Z3_" #X " ops",                                            \
    Z3_ ## X ## _finalize,                                              \
    custom_compare_default,                                             \
    custom_hash_default,                                                \
    custom_serialize_default,                                           \
    custom_deserialize_default,                                         \
    custom_compare_ext_default,                                         \
  };                                                                    \
                                                                        \
  MK_CTX_OF(X)



MK_PLUS_OBJ_NO_REF(symbol)
MK_PLUS_OBJ_NO_REF(constructor)
MK_PLUS_OBJ_NO_REF(constructor_list)
MK_PLUS_OBJ_NO_REF(rcf_num)
MK_PLUS_OBJ(params)
MK_PLUS_OBJ(param_descrs)
MK_PLUS_OBJ(model)
MK_PLUS_OBJ(func_interp)
MK_PLUS_OBJ(func_entry)
MK_PLUS_OBJ(goal)
MK_PLUS_OBJ(tactic)
MK_PLUS_OBJ(probe)
MK_PLUS_OBJ(apply_result)
MK_PLUS_OBJ(solver)
MK_PLUS_OBJ(stats)
MK_PLUS_OBJ(ast_map)
MK_PLUS_OBJ(ast_vector)
MK_PLUS_OBJ(fixedpoint)
MK_PLUS_OBJ(optimize)


#ifdef __cplusplus
extern "C" {
#endif

CAMLprim DLL_PUBLIC value n_is_null(value p) {
  void * t = * (void**) Data_custom_val(p);
  return Val_bool(t == 0);
}

CAMLprim DLL_PUBLIC value n_mk_null( void ) {
  CAMLparam0();
  CAMLlocal1(result);  
  result = caml_alloc(1, 0);
  result = Val_int(0);
  CAMLreturn (result);
}

void MLErrorHandler(Z3_context c, Z3_error_code e)
{
  /* Internal do-nothing error handler. This is required to avoid that Z3 calls exit()
     upon errors, but the actual error handling is done by throwing exceptions in the
     n_* wrapper functions. */
}

void DLL_PUBLIC n_set_internal_error_handler(value a0)
{
  Z3_context _a0 = * (Z3_context*) Data_custom_val(a0);
  Z3_set_error_handler(_a0, MLErrorHandler);
}
